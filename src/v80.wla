; v80 CP/M (c) Kroc Camen 2023, MIT License
; a z80 assembler for Z80s
;
.INC    "cpm.wla"
.INC    "z80.wla"

init:
;===============================================================================
        ; check for an automatic file-reference,
        ; i.e. a file parameter was passed on the command line
        ;
        ; check filename first-letter in the built-in file-control-block
        ld      A,      [command_fcb.filename]
        cp      ' '+1                   ; non-visible char? $00-$20?
        jp      c,      help            ; show help msg and quit

        ; open file:
        xor     A                       ; start reading at record 0
        ld      [command_fcb.current_record],   A
        ld      C,      BDOS_OPEN
        ld      DE,     command_fcb     ; use default FileControlBlock
        call    BDOS
        and     A                       ; (set flags!)
        jp      m,      @err            ; $FF = error

        ; assemble the file
        ;-----------------------------------------------------------------------
        call    assemble
        ;-----------------------------------------------------------------------

        ; return to CP/M handler to quit the program
        ret

@err:   ld      C,      BDOS_PRNSTR
        ld      DE,     @str
        jp      BDOS

@str:   .ASC "File Not Found!$"

.BLOCK  "code"
;===============================================================================
row:                    .WORD $0000     ; current line-number in file
col:                    .BYTE $00       ; current column-number in file
char:                   .BYTE $00       ; current character

param:                  .BYTE $00       ; next parameter properties

; heap:
;-------------------------------------------------------------------------------
; as assembly progresses, the dictionary of symbols and deferred calculations
; will be built up here. this position is currently arbitrary and ideally I
; want the heap to build downwards from top of memory, even on the stack itself
.DEF    heap            $c000

head:                   .ADDR heap      ; current position on the heap
dict:                   .ADDR $000      ; addr of last dictionary-entry

; expression bytecode:
;-------------------------------------------------------------------------------
; calculations are compiled into bytecode to allow for later evaluation,
; i.e. for deferred calculations where a symbol is not yet known
;
.DEF    EXPR_NUMBER     0               ; a number (hexadecimal)
.DEF    EXPR_LABEL      1               ; a label (16-bit)
.DEF    EXPR_CONST      2               ; a constant (flexible size)
.DEF    EXPR_OP_LO      16              ; `<`: lo-byte operator
.DEF    EXPR_OP_HI      17              ; `>`: hi-byte operator
.DEF    EXPR_OP_ADD     32              ; `+`: add operator 
.DEF    EXPR_OP_SUB     33              ; `-`: subtract operator
.DEF    EXPR_OP_MUL     34              ; `*`: multiply operator
.DEF    EXPR_OP_DIV     35              ; `/`: divide operator
.DEF    EXPR_OP_AND     36              ; `&`: and operator
.DEF    EXPR_OP_OR      37              ; `|`: or operator
.DEF    EXPR_OP_XOR     38              ; `^`: xor operator
.DEF    EXPR_OP_NOT     39              ; `!`: not operator

expr:                   .ADDR $000      ; addr of last deferred expression


assemble:
;===============================================================================
; assembles a file:
;
; TODO: do the file opening here so that we can do includes
;-------------------------------------------------------------------------------
        ; parse a word from the input file (root context)
        ;-----------------------------------------------------------------------
        ; where we'll be assembling to
        ld      HL,     [code]
  
        ; skip leading whitespace:
        ;-----------------------------------------------------------------------
@word:  call    getChar                 ; read a character (returns z-flag)
        ret     z                       ; return C=0 for no word, end-of-file
        cp      ASCII_SPC+1             ; ignore any ASCII code <= $20 (spc)
        jr      c, @word                ; keep reading blank chars

        ; first character determines the word type:
        cp      ';'                     ; is comment?
        jr      z,      @skip           ; skip until end of line

        call    parseInstruction

        jr      @word

        ; skip comments
        ;-----------------------------------------------------------------------
@skip:  call    getChar                 ; read next character (returns z-flag)
        ret     z                       ; return C=0 for no word, end-of-file
        cp      ASCII_LF                ; is newline?
        jr      nz, @word               ; keep going until new line
        jr      @word                   ; try get next word


parseInstruction:
;===============================================================================
; parse a Z80 instruction into opcodes:
;
; in:   HL              assembly addr to emit opcodes
; out:  HL              advanced to next [unused] addr
;       A|BC|DE         (clobbered)
;       IX|IY           (undefined)
;-------------------------------------------------------------------------------
.BLOCK  "opcode-parser"
        ld      DE,     opcodes         ; start at beginning of opcode tree

        ; the first character is already in A
        set     5,      A               ; force lowercase (see desc. below)
        jr      +                       ; jump into the parsing loop

        ;=======================================================================
        ; match; follow the branch
        ;-----------------------------------------------------------------------
@match: inc     DE                      ; step over the character to the addr
        ld      A,      [DE]            ; read the hi-byte / opcode-flags
        inc     DE                      ; move to lo-byte / opcode-byte

        ; is it a jump to another branch, or an opcode? (opcode-flags have
        ; to be in the hi-byte because a jump-address lo-byte could be >128)
        and     A                       ; (set flags)
        jp      m,      @opcode         ; high-bit set = this is an opcode

        ex      DE,     HL              ; swap DE|HL due to Z80 limitations
        ld      L,      [HL]            ; read lo-byte
        ld      H,      A               ; apply the hi-byte from before
        ex      DE,     HL              ; swap DE|HL back

        ; get character from input file:
        ;-----------------------------------------------------------------------
@char:  call    getChar                 ; read from input file
        cp      ASCII_SPC+1             ; is it whitespace? (hold carry...)

        ; force lowercase, without also affecting numbers/(most) punctuation:
        ;
        ; this essentially forces ASCII codes 64-95 (@A-Z[\]^_) to codes
        ; 96-127 (`a-z{|}~) which makes A-Z lowercase with the caveat that
        ; some punctuation cannot be differentiated "@"<->"`", "[]"<->"{}"",
        ; "\"<->"|" and "^"<->"~" but we aren't using any of those in the
        ; instruction names anyway
        ;
        ; it also means that ASCII codes 0-31 (non-visible) are promoted
        ; to 32-64 (visible), but we have already checked for ASCII codes
        ; 32 (space) or below and this is signalled by the carry flag; so
        ; even though the below instruction would change tab into ")", we
        ; will undo this afterwards
        ;
        set     5,      A               ; force partial lowercase
        jr      nc,     +               ; was this a non-visible char before?
        xor     A                       ; any whitespace = end-of-word (0)
+       ld      C,      A               ; set as character to compare against

        ;///////////////////////////////////////////////////////////////////////
        push    AF
        call    osPrintChar             ; DEBUG!
        pop     AF
        ;///////////////////////////////////////////////////////////////////////

        ; get character from opcode tree:
        ;-----------------------------------------------------------------------
@retry: ld      A,      [DE]            ; read from current position in tree
        and     A                       ; (set flags!)

        ; if the top-bit is set, this is either a continutation character
        ; (it must match and there is no branch) or an end of branch
        jp      m,      @cont

        ; does the character match the one in the opcode tree?
        cp      A,      C
        jr      z,      @match

        ; no match; try the next branch:
        ;-----------------------------------------------------------------------
@skip:  inc     DE
        inc     DE
        inc     DE
        jr      @retry

        ;-----------------------------------------------------------------------
        ; handle continuation character / end-of-branch:
        ;
        ; a continuation character has no branch, one character has to
        ; immediately follow another; any mismatch is an unknown opcode
        ;
        ; if, after removing the high-bit, the char is null, then we've reached
        ; the end of a branch and there are no more alternate paths to take.
        ; this is also an unknown opcode
        ;
@cont:  and     %01111111               ; remove top bit before comparison
        jr      z,      @err            ; end of branch? (128 -> 0)
        cp      A,      C               ; compare with input char
        jr      nz,     @err            ; if they don't match, error!
        inc     DE                      ; match -- move to next char in tree
        jr      @char

        ; emit opcode:
        ;-----------------------------------------------------------------------
@opcode ld      [param],        A       ; retain flags for parameter fetching
        ld      C,      A               ; retain the opcode-flags byte
        ld      A,      [DE]            ; read the opcode byte

        ; with the instruction matched to opcode, we no longer need
        ; the tree position; load up the virtual program-counter
        ld      DE,     [pc]

        ; the flags byte is a set of flags for Z80-specifics
        ; and what, if any, kind of parameter is required
        ;
        bit     4,      C               ; bit 4 indicates an IX instruction
        jr      z,      +
        ld      [HL],   $dd             ; emit IX prefix byte ($DD)
        inc     HL                      ; move to next byte in code segment
        inc     DE                      ; increment virtual program-counter

+       bit     6,      C               ; bit 6 indicates an IY instruction
        jr      z,      +
        ld      [HL],   $fd             ; emit IY prefix byte ($FD)
        inc     HL                      ; move to next byte in code segment
        inc     DE                      ; increment virtual program-counter

+       bit     3,      C               ; bit 3 indicates extended ($CB) opcode
        jr      z,      +               ; (these must appear after IX/IY bytes)
        ld      [HL],   $cb             ; emit $CB prefix byte
        inc     HL                      ; move to next byte in code segment
        inc     DE                      ; increment virtual program-counter

+       bit     5,      C               ; bit 5 indicates extended ($ED) opcode
        jr      z,      +               ; (these must appear after IX/IY bytes)
        ld      [HL],   $ed             ; emit $ED prefix byte
        inc     HL                      ; move to next byte in code segment
        inc     DE                      ; increment virtual program-counter
+

        ; TODO: DD|FB + CB opcodes put the opcode after the parameter!
        ; we'll have to reserve the parameter and return here

        ld      [HL],   A               ; now emit the opcode byte
        inc     HL

        ld      [code], HL              ; write back code segment position
        ld      [pc],   DE              ; write back virtual program-counter

        ; handle parameters:
        ;-----------------------------------------------------------------------
        call    parseParameter

        ;///////////////////////////////////////////////////////////////////////
        ld      A,      '-'
        call    osPrintChar             ; DEBUG!
        ;///////////////////////////////////////////////////////////////////////

        ld      HL,     [code]
        ret

        ; not a recognised opcode!
        ;-----------------------------------------------------------------------
@err:   ld      C,      BDOS_PRNSTR
        ld      DE,     @errstr
        call    BDOS

        ld      C,      BDOS_RESET
        jp      BDOS

        ret

@errstr .ASC    "Invalid opcode.$"

.ENDB

parseParameter:
;===============================================================================
; reserves bytes for a parameter value and parses the expression that follows;
; deferring evaluation
;-------------------------------------------------------------------------------
        ; add an expression to the heap,
        ; this requires:
        ;
        ; - the link addr to the previous expression
        ; - the current code-segment address
        ; - the size of the output; 1 or 2 bytes
        ; - the current virtual program-counter
        ;   (in case of relative jump)
        ; - the expression (as bytecode)
        ;
        ; link this expression to the previous:
        ; write the previous expr addr to the head of this one
        ; (preserving the previous addr)
        ;
        ld      DE,     [head]          ; get current heap position
        ld      HL,     expr            ; addr to read bytes from
        ldi                             ; (copy bytes across)
        ldi                             ; [DE]=[HL], DE++, HL++, BC--

        ; update the last expression field to point to this expression:
        ; warning: DE has already been advanced (by LDI), so we need to
        ; get the heap address again (without resetting DE)
        ld      HL,     [head]          ; start addr of our expression
        ld      [expr], HL              ; write to last expression addr

        ; write the current code-segment position;
        ; this is where the calculation result will be filled in
        ;
        ld      HL,     code            ; current code segment position
        ldi                             ; (copy bytes across)
        ldi                             ; [DE]=[HL], DE++, HL++, BC--

        ; set the size/type of the deferred result
        ld      HL,     param           ; parameter-type byte
        ldi                             ; (copy bytes across)
        ldi                             ; [DE]=[HL], DE++, HL++, BC--

        ; add the current virtual program-counter
        ; (for calculating relative jumps)
        ld      HL,     pc              ; virtual program-counter
        ldi                             ; (copy bytes across)
        ldi                             ; [HL]=[DE], HL++, DE++, BC--

        ; begin parsing the expression, packing it into bytecode
        ex      DE,     HL              ; (swap the current heap addr into HL)
        call    parseExpression

        ; attempt to evaluate the expression
        ; ...
        ld      [head], HL

        ret

parseExpression:
;===============================================================================
; parse an expression from the input file:
;
; words are read and converted into bytecode to evaluate later
; (e.g. deferred expression where a symbol is not yet known)
;
; this is different from regular parsing as it does not write
; to the code segment and opcodes are not permitted
;
; in:   HL              address on the heap to begin writing expr bytecode
;-------------------------------------------------------------------------------
        ; read the first character of the next word
        ; (skipping whitespace/comments)
        call    getChar
        jr      z,      @eof            ; handle unexpected eond of file!

        ; categorise it:
        cp      '0'                     ; before "0"?
        jr      c,      @lt0            ; <"0", not a number
        cp      '9'+1                   ; after "9"?
        jr      nc,     @gt9            ; >"9", not a number

        ; it's a number:
        ;-----------------------------------------------------------------------
        ; parse the number and store it in the expression
        ; 
        ret

        ; ASCII chars below "0" include only certain sigils supported!
        ;-----------------------------------------------------------------------
        ; `!` not operator, `"` strings, `#` constants, `%` modulo operator
        ; `&` and operator, `*` multiply operator, `+` add operator
        ; `-` subtract operator, `/` divide operator
        ;
@lt0:   halt
        ret

        ; ASCII chars above "9" include only certain sigils supported!
        ;-----------------------------------------------------------------------
        ; `:` label, `<` lo-byte operator, `>` hi-byte operator
        ; `^` xor operator, `|` or operator
        ;
@gt9:   halt
        ret

        ; TODO: need to make an osPrintString
        ;       how to handle CPM2's "$" terminator?
@eof:   ld      C,      BDOS_PRNSTR
        ld      DE,     @@str
        call    BDOS                    ; how to unfold?
        jp      0                       ; TODO: have proper osQuit?

        ; TODO: with any error, print out file name, line & col number
@@str   .BYTE "Unexpected end of file!"


parseNumber:
;===============================================================================
; parses an ASCII hexadecimal number and returns the value:
;
; in:   A               first ASCII character of the number
; out:  A               a width indicator, 0 = byte, 1 = word
;       BC              the value, 0 padded for numbers < 256
;-------------------------------------------------------------------------------
        ret


getChar:
;===============================================================================
; reads the next character in the file.
; current row and column are maintained
;
; TODO: handle tab (next 8th char boundary)
;
; out:  A                               ASCII code, 0 for end-of-file
;       DE, HL                          (preserved)
;       BC, IX/Y                        (undefined)
;-------------------------------------------------------------------------------
        call    osGetChar               ; read a char from file
        ld      [char], A               ; retain returned character

        ; if end-of-file, return the null byte;
        ; the caller will fold
        and     A                       ; (set flags)
        ret     z                       ; return on null byte

        ; check for end of line:
        ;-----------------------------------------------------------------------
        cp      ASCII_CR                ; /r is always ignored,
        jr      z,      __label__       ;  don't advance row/col, get next char

        exx                             ; must preserve HL & DE
        ld      HL',    col             ; prepare to increment column number

        cp      ASCII_LF                ; /n is newline
        jr      nz,     @col            ; if not, skip to next column

        ; increment line-number:
        ;-----------------------------------------------------------------------
        ld      DE',    [row]           ; 16-bit load,
        inc     DE'                     ;  and increment,
        ld      [row],  DE'             ;  and write
        ld      [HL'],  0               ; reset column number

        ; increment column number:
        ;-----------------------------------------------------------------------
        ; (capped at 255 even though lines can be longer)
@col:   inc     [HL']
        jr      nz,     +               ; if roll over, roll back (less
        dec     [HL']                   ;  instructions than read+add+write)

+       exx                             ; restore HL/DE
        ret

printHexByte:
;===============================================================================
; print a byte as hexadecimal:
;
; in:   A               byte to print
; out:  A               (clobbered)
;       BC|DE|HL|IXY    (undefined) -- depends on osPrintChar
;
; NOTE: multiple online sources cite this method, dating back to the 70s!
;-------------------------------------------------------------------------------
        push    AF
        rra
        rra
        rra
        rra
        call    @digit
        pop     AF
@digit: and     %00001111               ; isolate low-nybble
        add     $90                     ; magic?
        daa                             ; adjust to decimal
        adc     $40                     ; more magic?
        daa                             ; adjust to decimal
        jp      osPrintChar

.ENDB


; input buffer:
;===============================================================================
word_buff:
;-------------------------------------------------------------------------------
        .DSB 80, 0

; * * *   O B J E C T   C O D E   * * *
;===============================================================================
; this is where the assembled code will be placed;
; anything beyond this point will be overwritten
;
pc:     .WORD $0000                     ; assembly virtual program-counter
code:
;-------------------------------------------------------------------------------
        .WORD __code                    ; pointer to current position

__code: ; WARNING: ANYTHING PLACED AFTER HERE WILL BE OVERWRITTEN

;///////////////////////////////////////////////////////////////////////////////

help:
;===============================================================================
; print the help string:
;
; this isn't needed once assembly starts, so it gets overwritten
;-------------------------------------------------------------------------------
        ld      C,      BDOS_PRNSTR
        ld      DE,     @str
        jp      BDOS

@str:   .ASC "v80 CP/M v0, Kroc Camen 2023\n\n"
        .ASC "    V80 SOURCE.V80$"


/*getWord:
;===============================================================================
; read a word from the input file:
; (automatically skips comments)
;-------------------------------------------------------------------------------
        ld      C,      0               ; return C=0 if no words remaining

        ; skip leading whitespace:
        ;-----------------------------------------------------------------------
-       call    getChar                 ; read a character (returns z-flag)
        ret     z                       ; return C=0 for no word, end-of-file
        cp      ASCII_SPC+1             ; ignore any ASCII code <= $20 (spc)
        jr      c, -                    ; keep reading blank chars

        ; first character determines the word type
        cp      ';'                     ; is comment?
        jr      nz, +                   ; skip until end of line

        ; skip comments
        ;-----------------------------------------------------------------------
-       call    getChar                 ; read next character (returns z-flag)
        ret     z                       ; return C=0 for no word, end-of-file
        cp      ASCII_LF                ; is newline?
        jr      nz, -                   ; keep going until new line
        jr      __label__               ; try get next word

        ;-----------------------------------------------------------------------
        ; add the first character to the buffer
        ;
+       ld      HL,     word_buff       ; read into the word buffer (80 chars)
        inc     C                       ; set starting length of word
        ld      [HL],   A               ; write first character
        inc     HL                      ; move to next space in buffer

        ; read characters:
        ;-----------------------------------------------------------------------
@next:  call    getChar                 ; read next character
        cp      ASCII_SPC               ; check for non-visible character
        jr      nc,     +               ; stop if whitespace found
        inc     C                       ; increase character count
        ld      [HL],   A               ; add to the word buffer
        inc     HL                      ; and move to the next character
        jr      @next

        ; null-terminate the string
+       xor     A
        ld      [HL],   A

        ret*/