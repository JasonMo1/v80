; v80 CP/M (c) Kroc Camen 2023, MIT License
; a z80 assembler for Z80s
;
.INC    "cpm.wla"                       ; CP/M interface
.INC    "err.wla"                       ; error message handling
.INC    "z80.wla"                       ; static Z80 opcode binary tree

init:
;===============================================================================
        ld      DE,     @banner         ; print the program banner
        call    osPrintStr

        ; set heap position below stack:
        ;-----------------------------------------------------------------------
        ; this *assumes* we are at least 1 call deep on the stack,
        ; i.e. $FCFE rather than the unused stack top @ $FD00
        ;
        ld      HL,     $0000           ; oddly, there's no `ld HL, SP`!
        add     HL,     SP              ; stack address, e.g. $FCFE
        ex      DE,     HL              ; swap SP into DE
        ld      E,      0               ; use 0 for lo-byte, e.g. $FC00
        ld      [temp], DE              ; use bottom of stack for temp bytes
        ld      [heap], DE              ; finally set the heap position
        call    memStat                 ; print the memory status

        ; check for an automatic file-reference,
        ; i.e. a file parameter was passed on the command line
        ;-----------------------------------------------------------------------
        ; check filename first-letter in the built-in file-control-block
        ld      A,      [command_fcb.filename]
        cp      ' '+1                   ; non-visible char? $00-$20?
        jp      c,      help            ; show help msg and quit

        ; open file:
        xor     A                       ; start reading at record 0
        ld      [command_fcb.current_record],   A
        ld      C,      BDOS_OPEN
        ld      DE,     command_fcb     ; use default FileControlBlock
        call    BDOS
        and     A                       ; (set flags!)
        jp      m,      errFile         ; $FF = error

        ; assemble the file
        ;-----------------------------------------------------------------------
        call    assemble
        ;-----------------------------------------------------------------------

        ld      [heap], HL
        call    memStat
        ret                             ; return to CP/M to quit the program

        ;-----------------------------------------------------------------------
@banner .BYTE   "v80 CP/M v0, Kroc Camen 2023\n$"

memStat:
;===============================================================================
; prints memory status:
;-------------------------------------------------------------------------------
        ld      HL,     $0000           ; oddly, there's no `ld HL, SP`!
        add     HL,     SP              ; stack address, e.g. $FCFE
        ex      DE,     HL              ; swap SP into DE
        ld      HL,     @stack          ; stack addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     [heap]
        ld      HL,     @heap           ; heap addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     [code]
        ld      HL,     @code           ; code addr position in string
        call    @hex                    ; convert and insert

        ld      DE,     @mem
        jp      osPrintStr

        ;-----------------------------------------------------------------------
        ; convert DE to ASCII hexadecimal digits and insert in the string
        ;
@hex:   ld      A,      D
        call    @byte
        ld      A,      E
@byte:  call    getHexByte
        ld      [HL],   B
        inc     HL
        ld      [HL],   C
        inc     HL
        ret

        ;-----------------------------------------------------------------------
@mem    .BYTE   "[stack: "
@stack  .BYTE   "0000"
        .BYTE   " | heap: "
@heap   .BYTE   "0000"
        .BYTE   " | code: "
@code   .BYTE   "0000"
        .BYTE   "]\n$"


.BLOCK  "code"
;===============================================================================
; the bottom of the stack, just above the heap,
; can be used as temporary space for a few bytes
temp:   .ADDR $fc00                     ; (set during initialisation)
sp:     .ADDR $fcff                     ; stack pointer backup

char:   .BYTE $00                       ; current character

row:    .WORD $0000                     ; current line-number in file

; NOTE: these two bytes are specifically grouped together because
;       they are required by expressions written to the heap,
;       and are pushed together as a single word
expr_param_col:
param:  .BYTE $00                       ; next parameter properties
col:    .BYTE $00                       ; current column-number in file

; heap:
;-------------------------------------------------------------------------------
; as assembly progresses, the dictionary of symbols and deferred expressions
; will be built up on the heap. it works downwards from the top of memory
; in order to maximise the available space before the assembled binary
; and heap collide. during initialisation the heap will be placed 256 bytes
; below the stack at the top of memory, giving enough room for the stack
;
; like the stack, the heap is pre-decrement meaning that the heap address
; is decremented first before writing a value, ergo the heap addr points
; to a currently occupied byte on the heap
;
heap:   .ADDR $fc00                     ; current position on the heap

; dictionaries:
;-------------------------------------------------------------------------------
; labels and constants are stored as a linked-list of dictionary entries.
; each has its own entry point to avoid wasting time searching for labels
; amongst constants and vice-versa. $0000 terminates the list
;
; although the heap extends downwards, the link address has to point to
; the lo-byte of the entry's link field which is technically the 2nd byte
; of the record
;                     +------+
;          .--------->| addr |  (entry point)
;       2. |          +--|---+
; - - -----+------+      | 1.
;  ...data | addr | <----'      (heap extends downwards)
; - - -----+------+
;
label:  .ADDR $000                      ; addr of last label dictionary-entry
const:  .ADDR $000                      ; addr of last const dictionary-entry

; expression bytecode:
;-------------------------------------------------------------------------------
; calculations are compiled into bytecode to allow for later evaluation,
; i.e. for deferred calculations where a symbol is not yet known
;
.DEF    EXPR_END        0               ; expression terminator
.DEF    EXPR_NUMBER     '$'             ; hexadecimal literal
.DEF    EXPR_LABEL      ':'             ; a label (16-bit)
.DEF    EXPR_CONST      '#'             ; a constant (flexible size)
.DEF    EXPR_OP_LO      '<'             ; `<`: lo-byte operator
.DEF    EXPR_OP_HI      '>'             ; `>`: hi-byte operator
.DEF    EXPR_OP_NOT     '!'             ; `!`: not operator
.DEF    EXPR_OP_ADD     '+'             ; `+`: add operator 
.DEF    EXPR_OP_SUB     '-'             ; `-`: subtract operator
.DEF    EXPR_OP_MUL     '*'             ; `*`: multiply operator
.DEF    EXPR_OP_DIV     '/'             ; `/`: divide operator
.DEF    EXPR_OP_AND     '&'             ; `&`: and operator
.DEF    EXPR_OP_OR      '|'             ; `|`: or operator
.DEF    EXPR_OP_XOR     '^'             ; `^`: xor operator
.DEF    EXPR_OP_MOD     '%'             ; `%`: modulo operator

expr:   .ADDR $0000                     ; addr of last expression


assemble:
;===============================================================================
; assembles a file:
;
; TODO: do the file opening here so that we can do includes
;-------------------------------------------------------------------------------
        ; the virtual program counter is permanently pinned to IX since
        ; it's a value that needs to be incremented often but not read
        ; back too often. this avoids a bunch of HL/DE register swapping
        ;
        ld      IX,     $0100           ; virtual program-counter
        ld      HL,     [heap]          ; where symbols / expressions go
        ld      DE,     [code]          ; where code is assembled to

        ; parse root scope:
        ;-----------------------------------------------------------------------
@word:  call    skipWhitespace          ; find first character

        ; first character determines the word type:
        cp      ';'                     ; is comment?
        jr      z,      @skip           ; skip until end of line
        cp      ':'                     ; is label?
        jr      z,      @label          ; define a label

        call    parseInstruction

        ;///////////////////////////////////////////////////////////////////////
        ld      A,      ASCII_LF
        call    osPrintChar             ; DEBUG!
        ;///////////////////////////////////////////////////////////////////////
        ret

        ; skip comments:
        ;=======================================================================
@skip:  call    getChar                 ; read next character (returns z-flag)
        ret     z                       ; return on end-of-file
        cp      ASCII_LF                ; is newline?
        jr      nz, @word               ; keep going until new line
        jr      @word                   ; try get next word

        ; define label:
        ;=======================================================================
@label: call    readWord                ; read the label in
        ; TODO: check if label already exists
        call    pushLabel               ; define label on the heap
        ret


skipWhitespace:
;===============================================================================
; reads input until a visible character (ASCII >32) is reached:
; 
; out:  A               ASCII code. 0 = end-of-file
;-------------------------------------------------------------------------------
-       call    getChar                 ; read a character (returns z-flag)
        ret     z                       ; return z-flag set if end-of-file
        cp      ASCII_SPC+1             ; ignore any ASCII code <= $20 (spc)
        jr      c, -                    ; keep reading blank chars
        ret

readWord:
;===============================================================================
; reads a word into a buffer:
;
; NOTE: an error occurs if a word is > 32 chars long.
;       this routine doesn't handle strings
;
; in:   A               first character of word already read
; out:  HL              (preserved)
;       A, BC           (clobbered)
;       DE|IX|IY        (undefined) -- depends on osGetChar
;-------------------------------------------------------------------------------
        push    HL                      ; preserve HL coming in

        ; we use the bottom of the stack to hold the incoming word;
        ; because this is page-aligned we can get away with using
        ; `INC L` instead of `INC HL`
        ;
        ld      HL,     [temp]          ; bottom of stack, e.g. $FC00
        inc     L                       ; first byte will hold word-length
        ld      B,      32              ; B = max word-length
        jr      +                       ; (skip first character)
        ;-----------------------------------------------------------------------
-       call    osGetChar               ; read char form input file
        cp      ASCII_SPC+1             ; whitespace?
        jr      c,      @ok             ; (leave loop at whitespace)
+       ld      [HL],   A               ; add the character to the buffer
        inc     L                       ; move to next space in buffer
        djnz    -                       ; keep looping until B=0
        ;-----------------------------------------------------------------------
        jp      errWord                 ; word too long!

        ;-----------------------------------------------------------------------
@ok:    ld      [HL],   EXPR_END        ; terminate the word buffer
        ld      A,      32              ; 32 - characters remaining
        sub     B                       ; = length of word
        ld      [temp], A               ; write length to first byte

        pop     HL                      ; restore HL going out
        ret

pushLabel:
;===============================================================================
; push a new label to the heap:
; WARN: does not check if the label already exists!
; 
; in:   HL              heap position to write new label
;       temp            the label is assumed to be in the temp word buffer,
;                       i.e. after calling `readWord`
; out:  HL              heap position is advanced (downwards!)
;       A, BC|DE        clobbered
;-------------------------------------------------------------------------------
        ; link this label to the previous one:
        ;
        ld      DE,     [label]         ; read prev label addr
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   D               ; write prev label addr hi-byte
        dec     HL                      ; (this is the heap addr we want)
        ld      [HL],   E               ; write prev label addr lo-byte
        ld      [label],DE              ; update entry point with heap addr

        ; push the label value, which is
        ; the virtual program-counter:
        dec     HL                      ; pre-decrement heap to empty byte
        ld      A,      IXH
        ld      [HL],   A
        dec     HL
        ld      A,      IXL
        ld      [HL],   A
ret

.BLOCK  "code-parser"

parseInstruction:
;===============================================================================
; parse a Z80 instruction into opcodes:
;
; in:   A               first character of word to parse
;       HL              heap addr
;       DE              code-segment addr where opcodes are written
; out:  HL              heap addr is advanced for any expressions
;       A, BC|DE        (clobbered)
;-------------------------------------------------------------------------------
        push    HL                      ; preserve heap addr
        ld      HL,     opcodes         ; start at beginning of opcode tree

        ; the first character is already in A
        set     5,      A               ; force lowercase (see desc. below)
        jr      +                       ; jump into the parsing loop

        ;=======================================================================
        ; match; follow the branch:
        ;-----------------------------------------------------------------------
@match: inc     HL                      ; step over the character to the addr
        ld      A,      [HL]            ; read the hi-byte / opcode-flags
        inc     HL                      ; move to lo-byte / opcode-byte

        ; is it a jump to another branch, or an opcode? (opcode-flags have
        ; to be in the hi-byte because a jump-address lo-byte could be >128)
        and     A                       ; (set flags)
        jp      m,      @opcode         ; high-bit set = this is an opcode

        ld      L,      [HL]            ; read lo-byte
        ld      H,      A               ; apply the hi-byte from before

        ; get character from input file:
        ;-----------------------------------------------------------------------
@char:  call    getChar                 ; read from input file
        cp      ASCII_SPC+1             ; is it whitespace? (hold carry...)

        ; force lowercase, without also affecting
        ; numbers / [most] punctuation:
        ;
        ; this essentially forces ASCII codes 64-95 (@A-Z[\]^_) to codes
        ; 96-127 (`a-z{|}~) which makes A-Z lowercase with the caveat that
        ; some punctuation cannot be differentiated "@"<->"`", "[]"<->"{}"",
        ; "\"<->"|" and "^"<->"~" but we aren't using any of those in the
        ; instruction names anyway
        ;
        ; it also means that ASCII codes 0-31 (non-visible) are promoted
        ; to 32-64 (visible), but we have already checked for ASCII codes
        ; 32 (space) or below and this is signalled by the carry flag; so
        ; even though the below instruction would change tab into ")", we
        ; will undo this afterwards
        ;
        set     5,      A               ; force partial lowercase
        jr      nc,     +               ; was this a non-visible char before?
        xor     A                       ; any whitespace = end-of-word (0)
+       ld      C,      A               ; set as character to compare against

        ;///////////////////////////////////////////////////////////////////////
        push    AF
        call    osPrintChar             ; DEBUG!
        pop     AF
        ;///////////////////////////////////////////////////////////////////////

        ; get character from opcode tree:
        ;-----------------------------------------------------------------------
@retry: ld      A,      [HL]            ; read from current position in tree
        and     A                       ; (set flags!)

        ; if the top-bit is set, this is either a continuation character
        ; (it must match and there is no branch) or an end of branch
        jp      m,      @cont

        ; does the character match the one in the opcode tree?
        cp      A,      C
        jr      z,      @match

        ; no match; try the next branch:
        ;-----------------------------------------------------------------------
@skip:  inc     HL
        inc     HL
        inc     HL
        jr      @retry

        ;-----------------------------------------------------------------------
        ; handle continuation character / end-of-branch:
        ;
        ; a continuation character has no branch, one character has to
        ; immediately follow another; any mismatch is an unknown opcode
        ;
        ; if, after removing the high-bit, the char is null, then we've reached
        ; the end of a branch and there are no more alternate paths to take.
        ; this is also an unknown opcode
        ;
@cont:  and     %01111111               ; remove top bit before comparison
        jp      z,      errOpcode       ; end of branch? (128 -> 0)
        cp      A,      C               ; compare with input char
        jp      nz,     errOpcode       ; if they don't match, error!
        inc     HL                      ; match -- move to next char in tree
        jr      @char

        ;=======================================================================
        ; emit opcode(s):
        ;
@opcode ld      [param],A               ; retain flags for parameter fetching
        ld      B,      A               ; and again
        ld      C,      [HL]            ; read the opcode byte
        pop     HL                      ; return to heap addr in HL
        push    BC                      ; keep opcode until emit time
        ex      DE,     HL              ; swap code to HL, heap to DE
                                        ; (writing opcodes is easier in HL)

        ; is there any parameter?
        bit     2,      A               ; bit 2 indicates a parameter
        jr      nz,     +               ; if yes, handle parameter type

        ; no parameter!
        ex      DE,     HL              ; swap heap back to HL, code to DE
        jp      @emit                   ; write the opcode byte to code-segment

        ;-----------------------------------------------------------------------
        ; the flags byte is a set of flags for Z80-specifics
        ; and what, if any, kind of parameter is required
        ;
+       bit     4,      A               ; bit 4 indicates an IX instruction
        jr      z,      +
        ld      [HL],   $dd             ; emit IX prefix byte ($DD)
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter

        ;-----------------------------------------------------------------------
+       bit     6,      A               ; bit 6 indicates an IY instruction
        jr      z,      +
        ld      [HL],   $fd             ; emit IY prefix byte ($FD)
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter

        ;-----------------------------------------------------------------------
+       bit     5,      A               ; bit 5 indicates extended ($ED) opcode
        jr      z,      +               ; (these must appear after IX/IY bytes)
        ld      [HL],   $ed             ; emit $ED prefix byte
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter

        ;-----------------------------------------------------------------------
+       bit     3,      A               ; bit 3 indicates extended ($CB) opcode
        jr      z,      +               ; (these must appear after IX/IY bytes)
        ld      [HL],   $cb             ; emit $CB prefix byte
        inc     HL                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter

        ex      DE,     HL              ; swap heap back to HL, code to DE

        ; on the Z80, a combination of $DD|$FB (IX|IY) + $CB opcodes place
        ; the opcode after the parameter! if this is the case, we have to
        ; insert the parameter first, then return for the opcode
        ;
        and     %01010000               ; is IX|IY bit set as well?
        jr      z,      +               ; if not, $CB prefix without IX|IY

        call    pushExpr                ; emit parameter first,
        jp      @emit                   ;  and then the opcode byte

        ;-----------------------------------------------------------------------
+       call    @emit                   ; emit opcode byte,
        jp      pushExpr                ;  and then the parameter

        ;-----------------------------------------------------------------------
        ; emit the main opcode byte:
        ;
@emit:  pop     BC                      ; retrieve opcode bytes
        ld      A,      C               ; Z80 opcode byte
        ld      [DE],   A               ; emit opcode byte to code-segment
        inc     DE                      ; move to next byte in code-segment
        inc     IX                      ; increment virtual program-counter
        ld      [code], DE              ; write back updated addr
        ret

.ENDB

pushExpr:
;===============================================================================
; push an expression to the heap:
;
; - the link addr to the previous expression
; - the current code-segment address
; - the current virtual program-counter
;   (in case of relative jump)
; - the current line number in the input file
; - the current column number in the input file
; - the size of the output; 1 or 2 bytes
;   (in case of error)
; - the expression (as tokens)
;
; in:   HL              heap position
;       DE              code-segment addr
;       IX              virtual program-counter
;
; out:  HL              updated heap position (expr added to heap)
;       DE              updated code-segment addr (expr result space reserved)
;       IX              updated virtual program-counter (as with DE)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        ; we need to push a bunch of values to the heap and the fastest way
        ; to write 16-bit values easily is... the stack! simply make the heap
        ; into the stack and we can PUSH our stuff on to it!
        ;
        ; WE DO NOT NEED TO DISABLE INTERRUPTS!!! any interrupt is going to
        ; push to our heap and then pop the address off when it returns,
        ; which has no affect on the values we're pushing
        ;
        ld      [sp],   SP              ; backup stack pointer
        ld      SP,     HL              ; move stack to heap!
        ;-----------------------------------------------------------------------

        ; link this expression to the previous one:
        ; (since the heap address is in SP, we can reuse HL)
        ;
        ld      HL,     [expr]          ; get previous expr address
        push    HL                      ; write to heap
        ld      [expr], SP              ; write heap addr to the entry point!

        ; push the current code-segment position; this is where
        ; the expression result will be filled in after evaluation
        push    DE

        ; push the current virtual program-counter
        ; (for calculating relative jumps)
        push    IX                      ; PC is always stored in IX, not RAM

        ; push the source file line-number
        ld      BC,     [row]
        push    BC
        ; push the source file column-number, plus the opcode
        ; flags byte that gives the type/size of the result
        ld      BC,     [expr_param_col]
        push    BC

        ; reserve bytes for the expr result:
        ;
        ; this routine is only called if there is a parameter, which assumes
        ; a minimum of 1 byte. check the bit for a 16-bit parameter (e.g. JP).
        ;
        ; NOTE: the opcode-flags byte is in C, from the load above
        bit     1,      C               ; bit 1 indicates a 16-bit parameter
        jr      z,      +
        inc     DE                      ; reserve a byte and increment
        inc     IX                      ;  virtual program-counter
+       inc     DE                      ; reserve an additional byte
        inc     IX                      ;  and increment program-counter
        ld      [code], DE              ; write back updated code-segment addr

        ;-----------------------------------------------------------------------
        ld      HL,     0               ; there is no `LD HL, SP` (!?), so
        add     HL,     SP              ;  it's quicker to just add SP to 0!
        ld      SP,     [sp]            ; restore stack pointer!

        ; begin parsing the expression, packing it into bytecode:
        ;-----------------------------------------------------------------------
        call    skipWhitespace          ; read first character of the next word
        jp      z,      errExpr         ; unexpected end of file!

        push    DE                      ; (doesn't need code-segment addr?)
        call    parseExpr               ; -- addr to write is in expr header
        pop     DE

        ; attempt to evaluate the expression
        ; ...

        ret

; parseExpr:
;===============================================================================
; parse an expression from the input file:
;
; words are read and converted into tokens to evaluate later
; (e.g. deferred expressions where a symbol is not yet known)
;
; WARN: the first character of the expression is assumed to be read and
;       the first character of the next word following the expression
;       will be returned! this allows chaining of expressions, but you
;       must avoid losing the unused character between calls!
;
; in:   A               first character of the expression
;       HL              address on the heap to begin writing expr tokens
; out:  A               unused first character of the next word!
;       HL              updated heap address
;       A, BC|DE        (clobbered)
;-------------------------------------------------------------------------------
-       dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   A               ; push token in A to heap

        call    skipWhitespace          ; read first character of the next word
        jp      z,      errExpr         ; unexpected end of file!

parseExpr:
        ;=======================================================================
        ; an expression must begin with either a value,
        ; or a unary operator + a value
        ;
        ; unary operator?
        ;-----------------------------------------------------------------------
        ; unary operators can always precede values,
        ; even after an operator, e.g. `$10 + <:label`
        ;
@unary: cp      '<'                     ; lo-byte operator?
        jr      z,      +               ; a value must follow a unary operator
        ;-----------------------------------------------------------------------
        cp      '>'                     ; hi-byte operator?
        jr      z,      +               ; a value must follow a unary operator
        ;-----------------------------------------------------------------------
        cp      '!'                     ; not operator?
        jr      nz,     @value          ; no unary operators, check for values

        ; a unary operator has been added,
        ; read the next character:
+       dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   A               ; push a unary operator token

        call    skipWhitespace          ; read first character of the next word
        jp      z,      errEndOfFile    ; handle unexpected end of file!

        ; hexadecimal literal?
        ;-----------------------------------------------------------------------
        ; a sigil is required because A-F can't be separated
        ; from instruction names without look-ahead
        ;
@value: cp      '$'                     ; hexadecimal sigil?
        jr      nz,     +

        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   A               ; push a number token
        call    parseHexNumber          ; parse the hex number into BC
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   B               ; push the number hi-byte
        dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   C               ; push the number lo-byte

        jr      @operator               ; an operator can follow a value

        ; constant?
        ;-----------------------------------------------------------------------
+       cp      '#'                     ; a constant?
        jr      nz,     +

        halt

        ; label?
        ;-----------------------------------------------------------------------
+       cp      ':'                     ; a label?
        jp      nz,     errExpr         ; expression has no value!!
        
        halt

        ;-----------------------------------------------------------------------
        ; a value has been added, check for the presence of an operator:
        ; if there's no operator, the expression ends here
@operator:
        call    skipWhitespace          ; read first character of the next word
        jr      z,      @end            ; if end-of-file, end the expression

        cp      '+'                     ; add operator?
        jr      z,      -               ; push token to heap, find next operand
        cp      '-'                     ; subtract operator?
        jr      z,      -               ; ...
        cp      '*'                     ; multiply operator?
        jr      z,      -               ; ...
        cp      '/'                     ; divide operator?
        jr      z,      -               ; ...
        cp      '&'                     ; and operator?
        jr      z,      -               ; ...
        cp      '|'                     ; or operator?
        jr      z,      -               ; ...
        cp      '^'                     ; xor operator?
        jr      z,      -               ; ...
        cp      '%'                     ; modulo operator?
        jr      z,      -               ; ...

        ;-----------------------------------------------------------------------
        ; whatever it is, it isn't an operator;
        ; fall through and terminate the expression
        ;
@end:   dec     HL                      ; pre-decrement heap to empty byte
        ld      [HL],   EXPR_END        ; terminate the expression (0)
        ret


parseHexNumber:
;===============================================================================
; parses an ASCII hexadecimal number and returns the value:
;
; out:  BC              the value, 0 padded for numbers < 256
;       A, DE           (clobbered)
;       HL              (undefined) -- depends on osGetChar
;-------------------------------------------------------------------------------
        ld      C,      0               ; return value will go here

        ; try to read up to 4 digits; the 5th character
        ; must be whitespace or end-of-file!
        ;
        ; the bottom of the stack is used for temporary bytes (e.g. $FC00..)
        ; as we know this is page-aligned and can use INC L instead of INC HL
        ;
        ld      B,      5
        ld      DE,     [temp]          ; where to write the bytes
-       call    osGetChar               ; read a char from file
        cp      33                      ; ASCII space or below?
        jr      c,      +               ; stop when reaching whitespace
        ld      [DE],   A               ; append byte
        inc     L                       ; space for next digit
        djnz    -                       ; decrement B, loop until 0

        ; if a 5th byte was read that wasn't whitespace,
        ; it's an error -- the number is too long!
        jp      errHex

        ;-----------------------------------------------------------------------
+       ld      DE,     [temp]          ; go back to the start of the number
        
        ; number of digits in hex number is reversed;
        ; B=1 for 4 digits, B=2 for 3 digits, B=1 for 2 digits and B=0 for 1
        ;
        dec     B                       ; 4 digits?
        jr      z,      @four
        dec     B                       ; 3 digits?
        jr      z,      @three
        dec     B                       ; 2 digits?
        jr      z,      @two
        dec     B                       ; B=0 for 1-byte hex number in C
        jr      z,      @one

        ; if there were _no_ digits after the hexadecimal
        ; sigil ("$") then B was 5 and we error
        jp      errHex

        ; four-digit hex number:
        ;-----------------------------------------------------------------------
        ; a 4th digit must go in the upper nybble of B:
        ;
@four:  ld      A,      [DE]            ; get digit
        call    @digit                  ; convert digit to number
        add     A,      A               ;
        add     A,      A               ; left-shift (faster than `sla A`)
        add     A,      A               ; (shift lo-nybble to hi-nybble)
        add     A,      A               ;
        ld      B,      A               ; answer goes in B
        inc     L                       ; move to 3rd digit
        ;-----------------------------------------------------------------------
        ; a 3rd digit goes in the lower nybble of B:
        ;
@three: ld      A,      [DE]            ; get digit
        call    @digit                  ; convert digit to number
        or      B                       ; combine with hi-nybble (if present)
        ld      B,      A               ; answer goes in B
        inc     L                       ; move to 2nd digit
        ;-----------------------------------------------------------------------
        ; a 2nd digit goes in the upper nybble of C:
        ;
@two:   ld      A,      [DE]            ; get digit
        call    @digit                  ; convert digit to number
        add     A,      A               ;
        add     A,      A               ; left-shift (faster than `sla A`)
        add     A,      A               ; (shift lo-nybble to hi-nybble)
        add     A,      A               ;
        ld      C,      A               ; answer goes in C
        inc     L                       ; move to 1st digit
        ;-----------------------------------------------------------------------
        ; 1st digit goes in the lower nybble of C:
        ;
@one:   ld      A,      [DE]            ; get digit
        call    @digit                  ; convert digit to number
        or      C                       ; combine with hi-nybble (if present)
        ld      C,      A               ; answer goes in C

        ret                             ; ship it!

        ; convert a digit to a number:
        ;=======================================================================
        ; whitespace must already be precluded. err if not hex-digit
        ;
        ; valid hex digit?
        ;
        ; if we unset bit 5 then ASCII "a"-"f" (97-102) becomes "A"-"F" (65-70)
        ; without also altering existing uppercase letters. This also has the
        ; side-effect of changing ASCII "0"-"9" (30-39) to codes 16-25!
        ; (this is why ASCII codes 0-32 must be precluded beforehand)
        ;
@digit: res     5,      A               ; force upper-case for "a"-"f"
        sub     '0'                     ; anything < "0" becomes >=128 (hi-bit)
        cp      10                      ; 0-9 ("0"-"9") is okay
        ret     c                       ; exit early for 0-9

        ; between ASCII "9" and "A" is ":", ";", "<", "=", ">", "?" and "@";
        ; if we subtract 17, "A" becomes 0 and any of those 7 become negative
        ; (>=128, hi-bit set), therefore we only need to check 0-5 ("A"-"F")
        sub     17
        cp      6                       ; 0-5 ("A"-"F") are allowed
        jp      nc,     errHex          ; error for anything above "F"
        add     10                      ; rebase "A" to 10, "F" to 15

        ret


getChar:
;===============================================================================
; reads the next character in the file.
; current row and column are maintained
;
; TODO: handle tab (next 8th char boundary)
;
; out:  A                               ASCII code, 0 for end-of-file
;       z                               zero-flag is set according to A
;       DE, HL                          (preserved)
;       BC, IX/Y                        (undefined)
;-------------------------------------------------------------------------------
-       call    osGetChar               ; read a char from file
        ld      [char], A               ; retain returned character
        ret     z                       ; return on null byte (end-of-file)

        ; check for end of line:
        ;-----------------------------------------------------------------------
        cp      ASCII_CR                ; /r is always ignored,
        jr      z, -                    ;  don't advance row/col, get next char

        exx                             ; must preserve HL & DE
        ld      HL',    col             ; prepare to increment column number

        cp      ASCII_LF                ; /n is newline
        jr      nz,     @col            ; if not, skip to next column

        ; increment line-number:
        ;-----------------------------------------------------------------------
        ld      DE',    [row]           ; 16-bit load,
        inc     DE'                     ;  and increment,
        ld      [row],  DE'             ;  and write
        ld      [HL'],  0               ; reset column number

        ; increment column number:
        ;-----------------------------------------------------------------------
        ; (capped at 255 even though lines can be longer)
@col:   inc     [HL']
        jr      nz,     +               ; if roll over, roll back (less
        dec     [HL']                   ;  instructions than read+add+write)

+       exx                             ; restore HL/DE
        and     A                       ; return z-flag
        ret


printHexByte:
;===============================================================================
; print a byte as hexadecimal:
;
; in:   A               byte to print
; out:  A, BC           (clobbered)
;       DE|HL|IXY       (undefined) -- depends on osPrintChar
;-------------------------------------------------------------------------------
        call    getHexByte
        ld      A,      B
        call    osPrintChar
        ld      A,      C
        jp      osPrintChar

getHexByte:
;===============================================================================
; convert a byte into two ASCII hexadecimal digits:
;
; in:   A               input byte
; out:  BC              ASCII hex digits in hi,lo (printable) order
;       DE|HL|IX/Y      (preserved)
;       A               (clobbered)
;-------------------------------------------------------------------------------
        ld      B,      A               ; preserve for 2nd digit
        rra                             ;
        rra                             ; shift upper nybble down
        rra                             ;
        rra                             ;
        call    @digit                  ; convert to ASCII
        ld      A,      B               ; retrieve 2nd digit
        ld      B,      C               ; set upper ASCII digit

        ; fallthrough to convert 2nd digit
        ; ...

        ; NOTE: multiple online sources cite this method,
        ;       dating back to at least the 70s!
@digit: and     %00001111               ; isolate low-nybble
        add     $90                     ; magic!
        daa                             ; adjust to decimal
        adc     $40                     ; more magic!
        daa                             ; adjust to decimal
        ld      C,      A
        ret
.ENDB

; * * *   O B J E C T   C O D E   * * *
;===============================================================================
; this is where the assembled code will be placed;
; anything beyond this point will be overwritten
;
code:
;-------------------------------------------------------------------------------
        .ADDR __code                    ; pointer to current position

__code: ; WARNING: ANYTHING PLACED AFTER HERE WILL BE OVERWRITTEN

;///////////////////////////////////////////////////////////////////////////////

help:
;===============================================================================
; print the help string:
;
; this isn't needed once assembly starts, so it gets overwritten
;-------------------------------------------------------------------------------
        ld      DE,     @str
        jp      osPrintStr

@str    .BYTE "\n    V80 SOURCE.V80$"